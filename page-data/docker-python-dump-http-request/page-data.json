{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/docker-python-dump-http-request/","result":{"pageContext":{"id":"6571db8f04eb350fe3bda081","node":{"id":"6571db8f04eb350fe3bda081","slug":"docker-python-dump-http-request","url":"https://xprilion.com/docker-python-dump-http-request","title":"Docker Python Dump HTTP Request Example","featured":false,"subtitle":null,"brief":"This blog is an explanation for the code present in the github.com/xprilion/docker-python-dump-http-request-example repo.\nThe main purpose of the repo is to create a simple HTTP server developed using Python's Flask framework, hosted in a Docker envi...","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/HSACbYjZsqQ/upload/89a45a2d6ddf3a0a53b34fbdf3253d90.jpeg"},"content":{"html":"<p>This blog is an explanation for the code present in the <a target=\"_blank\" href=\"http://github.com/xprilion/docker-python-dump-http-request-example\">github.com/xprilion/docker-python-dump-http-request-example</a> repo.</p>\n<p>The main purpose of the repo is to create a simple HTTP server developed using Python's Flask framework, hosted in a Docker environment. The server is designed to log HTTP request and response data for debugging or informational purposes. The HTTP server receives requests, stores information about them, and then responds with a JSON representation of the request data.</p>\n<h2 id=\"heading-code-explanation\">Code Explanation</h2>\n<p>The repo contains the following files:</p>\n<pre><code class=\"lang-plaintext\">root/\n├── .dockerignore\n├── Dockerfile\n├── main.py\n└── requirements.txt\n</code></pre>\n<p>Let's go over these files in sequence of how they appear in the tree structure.</p>\n<h3 id=\"heading-dockerignorehttpsgithubcomxpriliondocker-python-dump-http-request-exampleblobmaindockerignore\"><a target=\"_blank\" href=\"https://github.com/xprilion/docker-python-dump-http-request-example/blob/main/.dockerignore\">.dockerignore</a></h3>\n<p>The <code>.dockerignore</code> file specifies a pattern for each file or directory that should be ignored when building a Docker image using a Dockerfile. Here's what some lines in our <code>.dockerignore</code> file means:</p>\n<ol>\n<li><p><code>Dockerfile</code>: This line tells Docker to ignore the <code>Dockerfile</code> itself when building the Docker image. Although it might seem strange, this is a common practice. The <code>Dockerfile</code> is used to build the Docker image and is not usually required within the container itself.</p>\n</li>\n<li><p><code>*.pyc, *.pyo, *.pyd</code>: These lines tell Docker to ignore Python compiled files. When Python programs run, they often create compiled versions of the Python source code. These files are not needed to run the Python program, as Python can run the source code directly.</p>\n</li>\n<li><p><code>__pycache__</code>: This line tells Docker to ignore the <strong>pycache</strong> directory. When Python 3.2 and later versions run, they store compiled files in this directory. These files are not needed to run the Python program.</p>\n</li>\n<li><p><code>.pytest_cache</code>: This line tells Docker to ignore the .pytest_cache directory. This directory is created when running tests with pytest, a testing framework for Python. It is not needed to run the Python application, and including it in the Docker image would increase the size of the image without providing any benefits.</p>\n</li>\n</ol>\n<h3 id=\"heading-dockerfilehttpsgithubcomxpriliondocker-python-dump-http-request-exampleblobmaindockerfile\"><a target=\"_blank\" href=\"https://github.com/xprilion/docker-python-dump-http-request-example/blob/main/Dockerfile\">Dockerfile</a></h3>\n<p>This Dockerfile outlines the steps to create a Docker image for a Python application:</p>\n<ol>\n<li><p><code>FROM python:3.11-slim</code>: The base image is the official lightweight Python 3.11 image from Docker Hub.</p>\n</li>\n<li><p><code>ENV PYTHONUNBUFFERED True</code>: Sets the environment variable <code>PYTHONUNBUFFERED</code> to <code>True</code> to allow log messages to be immediately displayed.</p>\n</li>\n<li><p><code>ENV APP_HOME /app</code> and <code>WORKDIR $APP_HOME</code>: Sets <code>/app</code> as the working directory.</p>\n</li>\n<li><p><code>COPY . ./</code>: Copies the local code into the Docker image.</p>\n</li>\n<li><p><code>RUN pip install --no-cache-dir -r requirements.txt</code>: Installs the Python dependencies from <code>requirements.txt</code> file without storing the cache, for a smaller image.</p>\n</li>\n<li><p><code>CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 main:app</code>: Specifies the command to run when the Docker container is started. The application is served using the Gunicorn HTTP server, binding to the environment variable <code>$PORT</code>, with one worker process and eight threads. The timeout is set to 0 to disable worker timeouts, leaving scaling management to the hosting platform (e.g., Google Cloud Run). The application instance is accessed via <code>main:app</code>, where <code>main</code> is the Python module (file) and <code>app</code> is the Flask application instance.</p>\n</li>\n</ol>\n<h3 id=\"heading-mainpyhttpmainpy\"><a target=\"_blank\" href=\"http://main.py\">main.py</a></h3>\n<p>The <a target=\"_blank\" href=\"http://main.py\"><code>main.py</code></a> script is a Flask application that logs HTTP request and response data. Here's what it does:</p>\n<ol>\n<li><p><strong>Initialization</strong>: A new Flask application is created and debugging is enabled.</p>\n</li>\n<li><p><strong>Request Saving</strong>: The <code>save_request</code> function collects details from the incoming HTTP request, including endpoint, method, cookies, data, headers, arguments, form data, remote address, and file information, if any.</p>\n</li>\n<li><p><strong>Response Saving</strong>: The <code>save_response</code> function collects details from the HTTP response, including status code, status message, headers, and response data.</p>\n</li>\n<li><p><strong>Request and Response Logging</strong>: <code>before_request</code> logs the HTTP method and endpoint of each incoming request. <code>after_request</code> adds CORS headers to the response, logs the response data, and then returns the response.</p>\n</li>\n<li><p><strong>Root Endpoint Handling</strong>: The <code>hello_world</code> function responds to HTTP GET requests at the root (<code>/</code>) endpoint. It generates a unique identifier for the request, saves the request data, creates a response containing the request data in JSON format, sets a cookie, and returns the response.</p>\n</li>\n<li><p><strong>Server Launch</strong>: The server runs on all network interfaces (<code>0.0.0.0</code>) and listens on the port specified by the \"PORT\" environment variable, or 8080 if not set.</p>\n</li>\n</ol>\n<h3 id=\"heading-requirementstxthttpsgithubcomxpriliondocker-python-dump-http-request-exampleblobmainrequirementstxt\"><a target=\"_blank\" href=\"https://github.com/xprilion/docker-python-dump-http-request-example/blob/main/requirements.txt\">requirements.txt</a></h3>\n<p>A <code>requirements.txt</code> file in a Python project is used to specify the dependencies of the project along with their versions (optional).</p>\n<p>In this <code>requirements.txt</code> file, we load Flask and gunicorn, which are enough for us to build the project. In most real world projects there are far more dependencies and the <code>requirements.txt</code> file for such projects may span several dozen lines.</p>\n<p>When setting up the project, you can use <code>pip install -r requirements.txt</code> to install all of the dependencies. If version numbers are provided, pip will try to install the exact version numbers or else default to the latest available version.</p>\n<h2 id=\"heading-code-usage\">Code Usage</h2>\n<p>Now, a quick note on how you can quickly deploy this code to anywhere you want using docker:</p>\n<ol>\n<li><p><strong>Build the Docker image</strong>: Run the following command in the terminal, in the directory containing your Dockerfile. This command builds a Docker image with the tag <code>my-python-app</code>.</p>\n<pre><code class=\"lang-bash\"> docker build -t my-python-app .\n</code></pre>\n</li>\n<li><p><strong>Run the Docker container</strong>: Run the Docker container from the image you just created. Replace <code>$PORT</code> with the port number you want to use.</p>\n<pre><code class=\"lang-bash\"> docker run -p <span class=\"hljs-variable\">$PORT</span>:8080 -e PORT=8080 my-python-app\n</code></pre>\n<p> This command runs the Docker container, mapping the host's <code>$PORT</code> to the container's <code>8080</code> port, which the Flask application inside the Docker container is listening on.</p>\n</li>\n</ol>\n<p>Remember, you need to have Docker installed on your machine to execute these commands.</p>\n<p>In production scenarios, you would push your Docker image to a Docker registry (like Docker Hub, Google Container Registry, or AWS Elastic Container Registry), then pull and run the Docker image from machines where you want your application to run. Also, orchestration tools like Kubernetes, Docker Swarm, or managed services like Google Cloud Run, AWS ECS/Fargate could be used to handle deployment, scaling, and management of Docker containers in a production setting.</p>\n<p>When you hit the endpoint created by deploying this code, you'll get a response similar to the one below:</p>\n<pre><code class=\"lang-json\">{\n    <span class=\"hljs-attr\">\"uuid\"</span>: <span class=\"hljs-string\">\"f50cc7d0f26511eda4bb75c989e55f1e\"</span>,\n    <span class=\"hljs-attr\">\"endpoint\"</span>: <span class=\"hljs-string\">\"hello_world\"</span>,\n    <span class=\"hljs-attr\">\"method\"</span>: <span class=\"hljs-string\">\"GET\"</span>,\n    <span class=\"hljs-attr\">\"cookies\"</span>: {\n        <span class=\"hljs-attr\">\"cookie-name\"</span>: <span class=\"hljs-string\">\"cookie-value\"</span>\n    },\n    <span class=\"hljs-attr\">\"data\"</span>: <span class=\"hljs-string\">\"b''\"</span>,\n    <span class=\"hljs-attr\">\"headers\"</span>: {\n        <span class=\"hljs-attr\">\"Host\"</span>: <span class=\"hljs-string\">\"test-cloud-run-custom.xpri.dev\"</span>,\n        <span class=\"hljs-attr\">\"Cache-Control\"</span>: <span class=\"hljs-string\">\"max-age=0\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua\"</span>: <span class=\"hljs-string\">\"\\\"Chromium\\\";v=\\\"112\\\", \\\"Google Chrome\\\";v=\\\"112\\\", \\\"Not:A-Brand\\\";v=\\\"99\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Mobile\"</span>: <span class=\"hljs-string\">\"?0\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Platform\"</span>: <span class=\"hljs-string\">\"\\\"macOS\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Upgrade-Insecure-Requests\"</span>: <span class=\"hljs-string\">\"1\"</span>,\n        <span class=\"hljs-attr\">\"User-Agent\"</span>: <span class=\"hljs-string\">\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36\"</span>,\n        <span class=\"hljs-attr\">\"Accept\"</span>: <span class=\"hljs-string\">\"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Arch\"</span>: <span class=\"hljs-string\">\"\\\"arm\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Platform-Version\"</span>: <span class=\"hljs-string\">\"\\\"13.3.1\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Model\"</span>: <span class=\"hljs-string\">\"\\\"\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Bitness\"</span>: <span class=\"hljs-string\">\"\\\"64\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Wow64\"</span>: <span class=\"hljs-string\">\"?0\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Ch-Ua-Full-Version-List\"</span>: <span class=\"hljs-string\">\"\\\"Chromium\\\";v=\\\"112.0.5615.137\\\", \\\"Google Chrome\\\";v=\\\"112.0.5615.137\\\", \\\"Not:A-Brand\\\";v=\\\"99.0.0.0\\\"\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Fetch-Site\"</span>: <span class=\"hljs-string\">\"none\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Fetch-Mode\"</span>: <span class=\"hljs-string\">\"navigate\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Fetch-User\"</span>: <span class=\"hljs-string\">\"?1\"</span>,\n        <span class=\"hljs-attr\">\"Sec-Fetch-Dest\"</span>: <span class=\"hljs-string\">\"document\"</span>,\n        <span class=\"hljs-attr\">\"Accept-Language\"</span>: <span class=\"hljs-string\">\"en-US,en;q=0.9\"</span>,\n        <span class=\"hljs-attr\">\"X-Cloud-Trace-Context\"</span>: <span class=\"hljs-string\">\"7361fa590088de543df325a9832ab85e/4131215564459013469\"</span>,\n        <span class=\"hljs-attr\">\"Traceparent\"</span>: <span class=\"hljs-string\">\"00-7361fa590088de543df325a9832ab85e-395506aaf224f55d-00\"</span>,\n        <span class=\"hljs-attr\">\"X-Forwarded-For\"</span>: <span class=\"hljs-string\">\"2401:4900:xxxx:xxxx:xxxx:5400:xxxx:xxxx\"</span>,\n        <span class=\"hljs-attr\">\"X-Forwarded-Proto\"</span>: <span class=\"hljs-string\">\"https\"</span>,\n        <span class=\"hljs-attr\">\"Forwarded\"</span>: <span class=\"hljs-string\">\"for=\\\"[2401:4900:xxxx:xxxx:xxxx:5400:xxxx:xxxx]\\\";proto=https\"</span>,\n        <span class=\"hljs-attr\">\"Accept-Encoding\"</span>: <span class=\"hljs-string\">\"gzip, deflate, br\"</span>\n    },\n    <span class=\"hljs-attr\">\"args\"</span>: {},\n    <span class=\"hljs-attr\">\"form\"</span>: {},\n    <span class=\"hljs-attr\">\"remote_addr\"</span>: <span class=\"hljs-string\">\"169.xxx.xxx.xxx\"</span>,\n    <span class=\"hljs-attr\">\"files\"</span>: []\n}\n</code></pre>\n<p>This response is a JSON representation of the details of an HTTP GET request received by the server. Let's break down what each key-value pair means:</p>\n<ul>\n<li><p><code>\"uuid\": \"f50cc7d0f26511eda4bb75c989e55f1e\"</code>: This is a unique identifier for this request.</p>\n</li>\n<li><p><code>\"endpoint\": \"hello_world\"</code>: The name of the endpoint that was hit. It corresponds to the function handling the request in the Flask application.</p>\n</li>\n<li><p><code>\"method\": \"GET\"</code>: The HTTP method used for this request.</p>\n</li>\n<li><p><code>\"cookies\": {\"cookie-name\": \"cookie-value\"}</code>: The cookies sent with this request. In this case, there is one cookie named \"cookie-name\" with a value of \"cookie-value\".</p>\n</li>\n<li><p><code>\"data\": \"b''\"</code>: The data sent with this request. In this case, no data was sent.</p>\n</li>\n<li><p><code>\"headers\"</code>: This is a dictionary containing all the HTTP headers that were sent with the request. This includes information about the client, the accepted response types, and more.</p>\n</li>\n<li><p><code>\"args\": {}</code> and <code>\"form\": {}</code>: These would contain any query parameters or form data sent with the request. In this case, none were sent.</p>\n</li>\n<li><p><code>\"remote_addr\": \"169.254.1.1\"</code>: This is the IP address of the client that sent the request.</p>\n</li>\n<li><p><code>\"files\": []</code>: This would contain any files sent with the request. In this case, none were sent.</p>\n</li>\n</ul>\n<p>The server logs all of these details for each request it receives. This can be useful for debugging, analytics, and other purposes.</p>\n"},"publishedAt":"2023-05-13T06:30:00.000Z","seo":{"title":"130520231708","description":null},"tags":[{"slug":"blog"}]}}},"staticQueryHashes":[],"slicesMap":{}}