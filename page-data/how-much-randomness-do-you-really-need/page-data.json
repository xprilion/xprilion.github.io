{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/how-much-randomness-do-you-really-need/","result":{"pageContext":{"id":"662fa7bce0a1d85565d1c138","node":{"id":"662fa7bce0a1d85565d1c138","slug":"how-much-randomness-do-you-really-need","url":"https://xprilion.com/how-much-randomness-do-you-really-need","title":"How much Randomness do you really need?","featured":false,"subtitle":null,"brief":"tl;dr: This article doesn't tell you how to generate more random numbers, it asks you - do you need it? And also sort of tells you how to generate more random numbers along the way.\nIn a world full of choices, its easy to come across situations where...","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1714382074222/32b8af14-73ef-472a-a3e0-3d7c8fe29d9f.png"},"content":{"html":"<p>tl;dr: This article doesn't tell you how to generate more random numbers, it asks you - do you need it? And also sort of tells you how to generate more random numbers along the way.</p>\n<p>In a world full of choices, its easy to come across situations where you would want to offload the decision making to something as simple as a coin toss. Sometimes, you could also roll a dice for a large number of options. Or maybe several dices, with the increasing number of choices.</p>\n<p>The learned elite of the <a target=\"_blank\" href=\"https://math.stackexchange.com/\">Math Exchange</a> have some really <a target=\"_blank\" href=\"https://math.stackexchange.com/a/1200650\">good advice on how to generate any size of random numbers by something as simple as rolling a dice several times</a>. At the same time, it can be argued that generating a random number once is not enough, you need to do it several times and make a strategy to pick a number from them or using them.</p>\n<p>I shall not be presenting much of my case for why we need random numbers to be truly random, or how difficult it is to achieve, that has been discussed at length by several tech frontrunners -</p>\n<ol>\n<li><p><a target=\"_blank\" href=\"https://www.kdnuggets.com/2017/06/surprising-complexity-randomness.html\">The Surprising Complexity of Randomness on Kdnuggets</a></p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://qz.com/1642628/cloudflare-uses-lava-lamps-to-generate-a-crucial-resource\">Cloudflare uses lava lamps to generate a fundamental resource: Randomness on QZ</a></p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://www.cloudflare.com/en-gb/leagueofentropy/\">League of Entropy by Cloudflare</a></p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://www.americanscientist.org/article/the-quest-for-randomness\">The Quest for Randomness on American Scientist</a></p>\n</li>\n</ol>\n<p>Randomness is a fascinating aspect of both nature and technology. It underpins everything from the evolutionary processes of biology to the algorithms securing our most sensitive digital transactions. But when it comes to integrating randomness into our systems and models, how much do we truly need? And what does it mean for our outcomes?</p>\n<p><img src=\"https://i.imgur.com/uR4WuQ0.gif\" alt=\"Dilbert-Random-Number-Generator\" class=\"image--center mx-auto\" /></p>\n<p>How can we determine the levels of randomness of numbers?</p>\n<h2 id=\"heading-understanding-randomness\">Understanding randomness</h2>\n<p>Randomness comes in various forms, and can be divided into several types of randomness based on how difficult it is for them to be predicted:</p>\n<h3 id=\"heading-level-1-deterministic-sequence\">Level 1: Deterministic sequence</h3>\n<p>Remember the traffic lights at the crossing? The sequence in which the lights change - from green to yellow to red and then back to green - is deterministic. This means the sequence is predefined and follows a set schedule, ensuring that each light phase occurs predictably. This predictability helps manage traffic flow efficiently, prevents accidents, and ensures pedestrians and vehicles can anticipate changes and act accordingly.</p>\n<p><img src=\"https://imgs.xkcd.com/comics/random_number.png\" alt=\"Random Number\" class=\"image--center mx-auto\" /></p>\n<p>At this stage, there is no randomness.</p>\n<p>Any mathematical function with one to one mapping is deterministic in randomness if passed a linear or periodic sequence of inputs.</p>\n<h3 id=\"heading-level-2-pseudo-random-number-generators-prngs\">Level 2: Pseudo-Random Number Generators (PRNGs)</h3>\n<p>Probably the most widely used level of randomness in software development - the psuedo random number generators are the trick behind the random function in almost all major programming languages.</p>\n<p>While PRNGs do not offer better cryptographic security of other possible algorithms, they provide an essential balance between speed, efficiency, and a sufficient level of unpredictability for many practical applications. Their ability to rapidly produce large volumes of pseudo-random numbers underpins a wide range of scientific, industrial, and entertainment applications, making them a fundamental tool in the arsenal of developers and researchers.</p>\n<h3 id=\"heading-level-3-cryptographically-secure-pseudo-random-number-generators-csprngs\">Level 3: Cryptographically Secure Pseudo-Random Number Generators (CSPRNGs)</h3>\n<p>Unlike standard pseudo-random number generators, CSPRNGs are designed to produce sequences of numbers that are not only pseudo-random but also fulfill stringent cryptographic security criteria. This means that the numbers they generate cannot be feasibly predicted by attackers, even with knowledge of the generator's workings and prior outputs, making them indispensable in a variety of security-sensitive applications.</p>\n<p>When you log into a website, the session management system generates a unique session token using a CSPRNG. This token is a large random number that serves as a temporary identity for your session. Because CSPRNGs ensure that these numbers are unpredictable, it becomes extremely difficult for attackers to hijack your session by guessing the token, thereby safeguarding your data and interactions with the site.</p>\n<p>One of the most critical uses of CSPRNGs is in the generation of encryption keys. Whether for symmetric or asymmetric encryption, the strength of the encryption largely depends on the unpredictability of the key. CSPRNGs ensure that encryption keys are generated in a manner that makes them hard to predict, thus fortifying the encryption against attacks. Many authentication protocols require random challenges or tokens to be generated as part of the authentication process. CSPRNGs are used to produce these tokens to ensure they cannot be predicted by an attacker, thus securing the authentication mechanism.</p>\n<h3 id=\"heading-level-4-true-random-number-generators-trngs\">Level 4: True Random Number Generators (TRNGs)</h3>\n<p>True Random Number Generators (TRNGs) utilize fundamentally unpredictable physical processes to generate numbers. Unlike their pseudo-random counterparts, TRNGs do not rely on algorithms but instead on inherent randomness found in natural phenomena. This level of randomness is crucial in applications where the highest degree of unpredictability is required, such as in high-security cryptographic environments. For instance, the Lava lamps used by the good folk at Cloudflare!</p>\n<p>TRNGs are the gold standard when absolute randomness is required. By relying on unpredictable physical processes, they provide a level of security and fairness that pseudo-random number generators cannot match.</p>\n<p>Go check out <a target=\"_blank\" href=\"https://developers.cloudflare.com/randomness-beacon/\">Cloudflare Randomness Beacon</a> - drand for a state of the art TRNG implementation - <a target=\"_blank\" href=\"https://drand.love/\">https://drand.love/</a></p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1714395090796/5b52fd1b-5446-4b79-bdef-b4b47b6bd177.gif\" alt class=\"image--center mx-auto\" /></p>\n<p>True randomness - unpredictable and without patterns - has a mystical quality in science and engineering. However, running TRNGs is not a trivial task. It requires sophisticated hardware solutions to be running 24x7, failure-proof and without environmental bias.</p>\n<p>In contrast to true randomness, PRNGs are much easier. While the sequences are not genuinely random because they are initialized with a 'seed' and will repeat their sequence if the seed is reused. Yet, for most applications, from simulations to video games, pseudo-randomness suffices. It's easier to generate, replicate, and test, which makes it incredibly valuable in software development.</p>\n<h2 id=\"heading-understanding-hash-collision\">Understanding Hash Collision</h2>\n<p>A lot of requirements of randomness in software development are around generating unique hashes. That's where you try to come up with a string that when you put into your database, maybe as a unique identifier of a resource or a key, you want it to work without you having to explicitly check if its not already present in the database. Historically, using hash functions has worked out pretty well for this. However, there are times when the output of the hash function isn't unique and that's where the problem of Hash collision starts.</p>\n<p>A hash collision occurs when two distinct inputs - like different files or data strings - are processed through a hash function and, surprise, they end up with the same hash value. It's as if two completely different paths unexpectedly lead you to the same destination.</p>\n<p>In a perfect world, a hash function would give each unique input a unique hash, but due to the limitations of mathematics and the finite nature of hash values, collisions are theoretically possible. Think of it like this: if you're assigning a unique number to every star in the sky using a finite number of digits, eventually, you'll run out of numbers and have to repeat one.</p>\n<p>Now, why should you care? In contexts where hashes are used to verify the integrity of data or authenticate information, a collision can be exploited to deceive systems into accepting a malicious file in place of a legitimate one. This vulnerability can be a real Achilles' heel in cybersecurity.</p>\n<p><img src=\"https://i.imgflip.com/8oefha.jpg\" alt class=\"image--center mx-auto\" /></p>\n<p>PS: The above meme is based on experiment by Nat McHugh published on their blog: <a target=\"_blank\" href=\"https://natmchugh.blogspot.com/2015/02/create-your-own-md5-collisions.html\">Create your own md5 hash collision</a>.</p>\n<p>This is why, in the realm of cryptographic security, choosing robust hash functions, those with a lower likelihood of collisions, is crucial. MD5, once a poster child of hash functions, has shown its age and vulnerability, pushing the digital world towards more secure alternatives like SHA-256 or SHA-3.</p>\n<h2 id=\"heading-randomness-by-use-case\">Randomness by use case</h2>\n<p>You don't really always need a lot of randomness in your regular developer life. Let's walk you through some calculations -</p>\n<h3 id=\"heading-unique-system-assigned-usernames\">Unique System Assigned Usernames</h3>\n<p>Some applications designate system generated random usernames to their users on sign up, which the user may or may not be able to change later. For such systems, its important to have good randomness in place to ensure that each username is unique without needing manual/automated intervention.</p>\n<h4 id=\"heading-general-strategy\">General strategy:</h4>\n<p>Using a pseudo-random generator can suffice, combining a predictable element (like a timestamp or user initials) with a randomly generated number or string. This provides a balance between uniqueness and simplicity, avoiding the need for high-level security measures that true randomness would entail.</p>\n<h4 id=\"heading-my-strategy\">My strategy:</h4>\n<p>When working on such systems, I've usually utilized the user's email along with the unix timestamp in the following manner -</p>\n<ol>\n<li><p>Strip the email of all special characters</p>\n</li>\n<li><p>Hash it through md5 (yes, even though its not collision-proof)</p>\n</li>\n<li><p>Append the current timestamp.</p>\n</li>\n</ol>\n<p>You might wonder, why did I use md5 even though I've trolled it in the previous section? The answer lies in the question - what is the probability of two users signing up on my website with emails that can cause the md5 function to produce the same hash at the same Unix timestamp?</p>\n<p><strong>Collision Calculation</strong></p>\n<ol>\n<li><p><strong>Probability of same timestamp:</strong> Let's assume your site has ((N)) users registering in a day ((86400 seconds)). If user registrations are uniformly distributed (which they typically are not, but we'll assume for simplicity), the probability ((p_t)) that two users register in the same second is (( \\frac{1}{86400} )).</p>\n</li>\n<li><p><strong>Probability of MD5 collision:</strong> Even under conditions where two emails could hash to the same value, the actual observed incidence of MD5 collisions in non-adversarial contexts is exceedingly low. Conservatively, let’s assume the probability ((p_m)) of any two random strings producing the same MD5 hash is much less than the theoretical (( \\frac{1}{2^{128}} )) due to MD5's vulnerabilities. A rough estimate might place it around (( \\frac{1}{2^{64}} )) given practical considerations and known weaknesses.</p>\n</li>\n<li><p><strong>Combined probability:</strong> The combined probability ((P)) that two users have the same hash and register at the exact same second is roughly (( p_t \\times p_m = \\frac{1}{86400} \\times \\frac{1}{2^{64}} )).</p>\n</li>\n</ol>\n<p><strong>Numeric approximation:</strong></p>\n<p>Given that ((2^{64} \\approx 1.84 \\times 10^{19})) and ((86400 \\approx 8.64 \\times 10^{4})), the probability becomes:</p>\n<p>[[ P \\approx \\frac{1}{8.64 \\times 10^{4} \\times 1.84 \\times 10^{19}} \\approx \\frac{1}{1.59 \\times 10^{24}} ]]</p>\n<p>This probability is astronomically low, indicating that under normal circumstances (non-adversarial), the likelihood of a collision from two users signing up in the same second with a colliding MD5 hash is virtually nil.</p>\n<h3 id=\"heading-system-suggested-project-names-like-on-github\">System Suggested Project Names (like on GitHub)</h3>\n<p>Did you spot the cool, sometimes witty and weird project name suggestions that many websites, like Github, offer? There's a trick to generating these and I put those down into this repository - <a target=\"_blank\" href=\"https://github.com/xprilion/project-name-generator-api\">https://github.com/xprilion/project-name-generator-api</a>, a free hosted version of this api is available at - <a target=\"_blank\" href=\"https://project-name-generator-api.xprilion.com/\">https://project-name-generator-api.xprilion.com/</a>. The primary goal here is to provide memorable, yet unique project names that users can easily modify</p>\n<p>Turns out, not a lot of randomness is required for this use case. Similar to the previous use case, its okay to go along with even a single PRNG output of sufficient length. A simple algorithm can combine two or three words from a predefined list with some numeric values. The randomness here mainly helps in avoiding collisions and providing inspiration, rather than securing data.</p>\n<p><strong>Collision Calculation</strong></p>\n<p>To put together some math for this, if we selected 3 random words out of a 100 words pool for each (all pools having different set of words), and appended a random three digit number at the end,</p>\n<p>[[ \\text{Total combinations} = 100 \\times 100 \\times 100 \\times 900 ]]</p>\n<p>The total number of unique project names that can be generated is 900 million.</p>\n<p>Let's again assume a realistic scenario where ( N ) is 1 million project names are generated and using a 128-bit hash function:</p>\n<p>[[ P \\approx \\frac{N^2}{2M} ]]</p>\n<p>Where ( M ) is the hash space size ((2^{128})).</p>\n<p>The probability of a hash collision when generating 1,000,000 unique project names, using a combination of three words from different pools and a three-digit number, with a 128-bit hash function, is still approximately (1.47 \\times 10^{-27}). This remains an extremely low probability, indicating that the method is highly effective in preventing collisions even with a large number of names generated.</p>\n<p>To add on it, in a situation like Github's where projects are made unique by <code>username/repo-name</code>, every user would have to refresh the project creation page millions of times to see the same suggestion twice.</p>\n<h3 id=\"heading-verification-tokens-for-user-account-creation-or-email-link-login\"><strong>Verification Tokens for User Account Creation or Email Link Login</strong></h3>\n<p>When the goal is to secure the token against guessing or brute-force attacks, ensuring that the token is valid only for the intended recipient and use case.</p>\n<p>True randomness or high-quality pseudo-randomness generated by cryptographic methods is ideal. These tokens should be unpredictable and not repeatable, as they are crucial for security.</p>\n<h4 id=\"heading-general-strategy-1\">General Strategy</h4>\n<p>A very common way of achieving this is through CSPRNG. In Python, you can use the <code>secrets</code> package to get CSPRNG sequences easily.</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-keyword\">import</span> secrets\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">generate_secure_token</span>(<span class=\"hljs-params\">length=<span class=\"hljs-number\">128</span></span>):</span>\n    <span class=\"hljs-comment\"># Generate a secure random token using secrets, which is suitable for cryptographic use</span>\n    <span class=\"hljs-keyword\">return</span> secrets.token_urlsafe(length)\n</code></pre>\n<p>This function uses the secrets module’s token_urlsafe method, which generates a secure random URL-safe token. The length parameter controls the token's complexity, and the output is suitable for cryptographic purposes.</p>\n<p><strong>Collision Calculation:</strong></p>\n<p>Assuming a token length to 128 characters and using a character set of 64 possible characters.</p>\n<p><strong>Number of Possible Tokens:</strong> ((64^{128})) (64 characters raised to the power of 128).</p>\n<p>Using the same birthday problem approximation:</p>\n<p>[[ P \\approx \\frac{N^2}{2M} ]]</p>\n<p>Where:</p>\n<ul>\n<li><p>(( N )) is the number of tokens generated (1,000,000 in this scenario).</p>\n</li>\n<li><p>(( M )) is ((64^{128}))</p>\n</li>\n</ul>\n<p>Let’s calculate the updated collision probability for this configuration:</p>\n<p>The probability of a hash collision when generating 1,000,000 verification tokens, each 128 characters long from a character set of 64 possible characters, is approximately ((3.22 \\times 10^{-220})).</p>\n<p>The token length of 128 characters vastly expands the possible token space, making collisions almost impossible under normal conditions. This provides an exceptionally robust method for generating secure verification tokens for critical applications such as secure login processes or user account verifications.</p>\n<p><img src=\"https://imgs.xkcd.com/comics/im_so_random.png\" alt=\"I'm So Random by xkcd: https://xkcd.com/1210\" class=\"image--center mx-auto\" /></p>\n<h2 id=\"heading-conclusion\">Conclusion</h2>\n<p>With the increasing ease of generation of highly random numbers (and brute-force guessing them in adversarial scenarios), its import to resits the temptation of using costlier algorithms unless absolutely necessary. True randomness is rarely required in the common software development process. Usually, determining the collision probability and constraining your needs within realistic scenarios will let you decide better on how much randomness to require and to eventually save both on computational and storage costs.</p>\n<p>Finally, remember, just because you have a great, truly random string as your password, doesn't mean it cannot be stolen - stay careful!</p>\n<p><img src=\"https://imgs.xkcd.com/comics/security.png\" alt=\"Security by xkcd: https://xkcd.com/538\" class=\"image--center mx-auto\" /></p>\n"},"publishedAt":"2024-04-29T13:59:24.656Z","seo":{"title":null,"description":null},"tags":[{"slug":"blog"}]}}},"staticQueryHashes":[],"slicesMap":{}}