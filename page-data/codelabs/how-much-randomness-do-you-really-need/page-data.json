{"componentChunkName":"component---src-templates-codelabs-codelab-tsx","path":"/codelabs/how-much-randomness-do-you-really-need/","result":{"pageContext":{"node":{"id":"662fa7bce0a1d85565d1c138","slug":"how-much-randomness-do-you-really-need","url":"https://xprilion.com/how-much-randomness-do-you-really-need","title":"How much Randomness do you really need?","subtitle":null,"brief":"tl;dr: This article doesn't tell you how to generate more random numbers, it asks you - do you need it? And also sort of tells you how to generate more random numbers along the way.\nIn a world full of choices, its easy to come across situations where...","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1714382074222/32b8af14-73ef-472a-a3e0-3d7c8fe29d9f.png"},"content":{"html":"<p>tl;dr: This article doesn't tell you how to generate more random numbers, it asks you - do you need it? And also sort of tells you how to generate more random numbers along the way.</p>\n<p>In a world full of choices, its easy to come across situations where you would want to offload the decision making to something as simple as a coin toss. Sometimes, you could also roll a dice for a large number of options. Or maybe several dices, with the increasing number of choices.</p>\n<p>The learned elite of the <a target=\"_blank\" href=\"https://math.stackexchange.com/\">Math Exchange</a> have some really <a target=\"_blank\" href=\"https://math.stackexchange.com/a/1200650\">good advice on how to generate any size of random numbers by something as simple as rolling a dice several times</a>. At the same time, it can be argued that generating a random number once is not enough, you need to do it several times and make a strategy to pick a number from them or using them.</p>\n<p>I shall not be presenting much of my case for why we need random numbers to be truly random, or how difficult it is to achieve, that has been discussed at length by several tech frontrunners -</p>\n<ol>\n<li><p><a target=\"_blank\" href=\"https://www.kdnuggets.com/2017/06/surprising-complexity-randomness.html\">The Surprising Complexity of Randomness on Kdnuggets</a></p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://qz.com/1642628/cloudflare-uses-lava-lamps-to-generate-a-crucial-resource\">Cloudflare uses lava lamps to generate a fundamental resource: Randomness on QZ</a></p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://www.cloudflare.com/en-gb/leagueofentropy/\">League of Entropy by Cloudflare</a></p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://www.americanscientist.org/article/the-quest-for-randomness\">The Quest for Randomness on American Scientist</a></p>\n</li>\n</ol>\n<p>Randomness is a fascinating aspect of both nature and technology. It underpins everything from the evolutionary processes of biology to the algorithms securing our most sensitive digital transactions. But when it comes to integrating randomness into our systems and models, how much do we truly need? And what does it mean for our outcomes?</p>\n<p><img src=\"https://i.imgur.com/uR4WuQ0.gif\" alt=\"Dilbert-Random-Number-Generator\" class=\"image--center mx-auto\" /></p>\n<p>How can we determine the levels of randomness of numbers?</p>\n<h2 id=\"heading-understanding-randomness\">Understanding randomness</h2>\n<p>Randomness comes in various forms, and can be divided into several types of randomness based on how difficult it is for them to be predicted:</p>\n<h3 id=\"heading-level-1-deterministic-sequence\">Level 1: Deterministic sequence</h3>\n<p>Remember the traffic lights at the crossing? The sequence in which the lights change - from green to yellow to red and then back to green - is deterministic. This means the sequence is predefined and follows a set schedule, ensuring that each light phase occurs predictably. This predictability helps manage traffic flow efficiently, prevents accidents, and ensures pedestrians and vehicles can anticipate changes and act accordingly.</p>\n<p><img src=\"https://imgs.xkcd.com/comics/random_number.png\" alt=\"Random Number\" class=\"image--center mx-auto\" /></p>\n<p>At this stage, there is no randomness.</p>\n<p>Any mathematical function with one to one mapping is deterministic in randomness if passed a linear or periodic sequence of inputs.</p>\n<h3 id=\"heading-level-2-pseudo-random-number-generators-prngs\">Level 2: Pseudo-Random Number Generators (PRNGs)</h3>\n<p>Probably the most widely used level of randomness in software development - the psuedo random number generators are the trick behind the random function in almost all major programming languages.</p>\n<p>While PRNGs do not offer better cryptographic security of other possible algorithms, they provide an essential balance between speed, efficiency, and a sufficient level of unpredictability for many practical applications. Their ability to rapidly produce large volumes of pseudo-random numbers underpins a wide range of scientific, industrial, and entertainment applications, making them a fundamental tool in the arsenal of developers and researchers.</p>\n<h3 id=\"heading-level-3-cryptographically-secure-pseudo-random-number-generators-csprngs\">Level 3: Cryptographically Secure Pseudo-Random Number Generators (CSPRNGs)</h3>\n<p>Unlike standard pseudo-random number generators, CSPRNGs are designed to produce sequences of numbers that are not only pseudo-random but also fulfill stringent cryptographic security criteria. This means that the numbers they generate cannot be feasibly predicted by attackers, even with knowledge of the generator's workings and prior outputs, making them indispensable in a variety of security-sensitive applications.</p>\n<p>When you log into a website, the session management system generates a unique session token using a CSPRNG. This token is a large random number that serves as a temporary identity for your session. Because CSPRNGs ensure that these numbers are unpredictable, it becomes extremely difficult for attackers to hijack your session by guessing the token, thereby safeguarding your data and interactions with the site.</p>\n<p>One of the most critical uses of CSPRNGs is in the generation of encryption keys. Whether for symmetric or asymmetric encryption, the strength of the encryption largely depends on the unpredictability of the key. CSPRNGs ensure that encryption keys are generated in a manner that makes them hard to predict, thus fortifying the encryption against attacks. Many authentication protocols require random challenges or tokens to be generated as part of the authentication process. CSPRNGs are used to produce these tokens to ensure they cannot be predicted by an attacker, thus securing the authentication mechanism.</p>\n<h3 id=\"heading-level-4-true-random-number-generators-trngs\">Level 4: True Random Number Generators (TRNGs)</h3>\n<p>True Random Number Generators (TRNGs) utilize fundamentally unpredictable physical processes to generate numbers. Unlike their pseudo-random counterparts, TRNGs do not rely on algorithms but instead on inherent randomness found in natural phenomena. This level of randomness is crucial in applications where the highest degree of unpredictability is required, such as in high-security cryptographic environments. For instance, the Lava lamps used by the good folk at Cloudflare!</p>\n<p>TRNGs are the gold standard when absolute randomness is required. By relying on unpredictable physical processes, they provide a level of security and fairness that pseudo-random number generators cannot match.</p>\n<p>Go check out <a target=\"_blank\" href=\"https://developers.cloudflare.com/randomness-beacon/\">Cloudflare Randomness Beacon</a> - drand for a state of the art TRNG implementation - <a target=\"_blank\" href=\"https://drand.love/\">https://drand.love/</a></p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1714395090796/5b52fd1b-5446-4b79-bdef-b4b47b6bd177.gif\" alt class=\"image--center mx-auto\" /></p>\n<p>True randomness - unpredictable and without patterns - has a mystical quality in science and engineering. However, running TRNGs is not a trivial task. It requires sophisticated hardware solutions to be running 24x7, failure-proof and without environmental bias.</p>\n<p>In contrast to true randomness, PRNGs are much easier. While the sequences are not genuinely random because they are initialized with a 'seed' and will repeat their sequence if the seed is reused. Yet, for most applications, from simulations to video games, pseudo-randomness suffices. It's easier to generate, replicate, and test, which makes it incredibly valuable in software development.</p>\n<h2 id=\"heading-understanding-hash-collision\">Understanding Hash Collision</h2>\n<p>A lot of requirements of randomness in software development are around generating unique hashes. That's where you try to come up with a string that when you put into your database, maybe as a unique identifier of a resource or a key, you want it to work without you having to explicitly check if its not already present in the database. Historically, using hash functions has worked out pretty well for this. However, there are times when the output of the hash function isn't unique and that's where the problem of Hash collision starts.</p>\n<p>A hash collision occurs when two distinct inputs - like different files or data strings - are processed through a hash function and, surprise, they end up with the same hash value. It's as if two completely different paths unexpectedly lead you to the same destination.</p>\n<p>In a perfect world, a hash function would give each unique input a unique hash, but due to the limitations of mathematics and the finite nature of hash values, collisions are theoretically possible. Think of it like this: if you're assigning a unique number to every star in the sky using a finite number of digits, eventually, you'll run out of numbers and have to repeat one.</p>\n<p>Now, why should you care? In contexts where hashes are used to verify the integrity of data or authenticate information, a collision can be exploited to deceive systems into accepting a malicious file in place of a legitimate one. This vulnerability can be a real Achilles' heel in cybersecurity.</p>\n<p><img src=\"https://i.imgflip.com/8oefha.jpg\" alt class=\"image--center mx-auto\" /></p>\n<p>PS: The above meme is based on experiment by Nat McHugh published on their blog: <a target=\"_blank\" href=\"https://natmchugh.blogspot.com/2015/02/create-your-own-md5-collisions.html\">Create your own md5 hash collision</a>.</p>\n<p>This is why, in the realm of cryptographic security, choosing robust hash functions, those with a lower likelihood of collisions, is crucial. MD5, once a poster child of hash functions, has shown its age and vulnerability, pushing the digital world towards more secure alternatives like SHA-256 or SHA-3.</p>\n<h2 id=\"heading-randomness-by-use-case\">Randomness by use case</h2>\n<p>You don't really always need a lot of randomness in your regular developer life. Let's walk you through some calculations -</p>\n<h3 id=\"heading-unique-system-assigned-usernames\">Unique System Assigned Usernames</h3>\n<p>Some applications designate system generated random usernames to their users on sign up, which the user may or may not be able to change later. For such systems, its important to have good randomness in place to ensure that each username is unique without needing manual/automated intervention.</p>\n<h4 id=\"heading-general-strategy\">General strategy:</h4>\n<p>Using a pseudo-random generator can suffice, combining a predictable element (like a timestamp or user initials) with a randomly generated number or string. This provides a balance between uniqueness and simplicity, avoiding the need for high-level security measures that true randomness would entail.</p>\n<h4 id=\"heading-my-strategy\">My strategy:</h4>\n<p>When working on such systems, I've usually utilized the user's email along with the unix timestamp in the following manner -</p>\n<ol>\n<li><p>Strip the email of all special characters</p>\n</li>\n<li><p>Hash it through md5 (yes, even though its not collision-proof)</p>\n</li>\n<li><p>Append the current timestamp.</p>\n</li>\n</ol>\n<p>You might wonder, why did I use md5 even though I've trolled it in the previous section? The answer lies in the question - what is the probability of two users signing up on my website with emails that can cause the md5 function to produce the same hash at the same Unix timestamp?</p>\n<p>For the fun of it, I let ChatGPT have a go at answering that.</p>\n<p><strong>Collision Calculation</strong></p>\n<p>Assuming each registration event is independent, the probability (P) that any two given hashes collide (i.e., are identical) under ideal conditions is</p>\n<p>$$\\frac{1}{2^{128}}$$</p><p>However, the introduction of the timestamp complicates direct collisions since both the hashed content (email) and the exact second of registration must match.</p>\n<p><strong>Step-by-step calculation:</strong></p>\n<ol>\n<li><p><strong>Probability of same timestamp:</strong> Let's assume your site has (N) users registering in a day (86,400 seconds). If user registrations are uniformly distributed (which they typically are not, but we'll assume for simplicity), the probability (p_t) that two users register in the same second is ( \\frac{1}{86400} ).</p>\n</li>\n<li><p><strong>Probability of MD5 collision:</strong> Even under conditions where two emails could hash to the same value, the actual observed incidence of MD5 collisions in non-adversarial contexts is exceedingly low. Conservatively, letâ€™s assume the probability (p_m) of any two random strings producing the same MD5 hash is much less than the theoretical ( \\frac{1}{2^{128}} ) due to MD5's vulnerabilities. A rough estimate might place it around ( \\frac{1}{2^{64}} ) given practical considerations and known weaknesses.</p>\n</li>\n<li><p><strong>Combined probability:</strong> The combined probability (P) that two users have the same hash and register at the exact same second is roughly ( p_t \\times p_m = \\frac{1}{86400} \\times \\frac{1}{2^{64}} ).</p>\n</li>\n</ol>\n<p><strong>Numeric approximation:</strong></p>\n<p>Given that (2^{64} \\approx 1.84 \\times 10^{19}) and (86400 \\approx 8.64 \\times 10^{4}), the probability becomes:</p>\n<p>$$P \\approx \\frac{1}{8.64 \\times 10^{4} \\times 1.84 \\times 10^{19}} \\approx \\frac{1}{1.59 \\times 10^{24}}$$</p><p>This probability is astronomically low, indicating that under normal circumstances (non-adversarial), the likelihood of a collision from two users signing up in the same second with a colliding MD5 hash is virtually nil.</p>\n"},"publishedAt":"2024-04-29T13:59:24.656Z","seo":{"title":null,"description":null},"tags":[{"slug":"codelab"}]}}},"staticQueryHashes":[],"slicesMap":{}}