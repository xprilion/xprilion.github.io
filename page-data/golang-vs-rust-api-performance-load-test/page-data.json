{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/golang-vs-rust-api-performance-load-test/","result":{"pageContext":{"id":"67160a847278a78c9a6f488c","node":{"id":"67160a847278a78c9a6f488c","slug":"golang-vs-rust-api-performance-load-test","url":"https://xprilion.com/golang-vs-rust-api-performance-load-test","title":"Golang vs Rust: API Performance Load Test","featured":false,"subtitle":null,"brief":"Roughly 8 months back, I wrote an article comparing the performance of Python against Golang, and the latter emerged a clear winner. I went on to explore Golang at depth and even delivered a few talks in which I leveraged the power of goroutines and ...","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1729496984950/4446cea8-a33c-4c51-85e4-492796375c86.png"},"content":{"html":"<p>Roughly 8 months back, I wrote <a target=\"_blank\" href=\"https://xprilion.com/golang-vs-python-api-performance-load-test/\">an article comparing the performance of Python against Golang</a>, and the latter emerged a clear winner. I went on to explore Golang at depth and even delivered a few talks in which I leveraged the power of goroutines and channels to build demos which showcased parallel processing and lightweight AI agent containerization.</p>\n<p>However, my quest for extreme optimisation kept luring me towards Rust every few weeks, until today, when I decided to make the languages go head-to-head in the one domain I work on often - building APIs. The code used for testing is available here - <a target=\"_blank\" href=\"https://github.com/xprilion/go-vs-rust-api-performance-test\">https://github.com/xprilion/go-vs-rust-api-performance-test</a>. I just ran the tests on my laptop without any changes in RAM/running apps while testing it.</p>\n<h3 id=\"heading-setting-up-the-servers\">Setting Up the Servers</h3>\n<p>To ensure an apples-to-apples comparison, I wrote minimal web servers in both Golang and Rust, which would be subjected to the same load tests. Since both languages offer compiling the code to performant binaries, I did that.</p>\n<p>Then I ran the binaries on port <code>8080</code> for Golang and <code>8081</code> for Rust and stress tested them using the <code>hey</code> tool.</p>\n<h4 id=\"heading-golang-server\">Golang Server</h4>\n<pre><code class=\"lang-go\"><span class=\"hljs-comment\">// server.go</span>\n<span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"net/http\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">greetHandler</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request)</span></span> {\n    fmt.Fprintf(w, <span class=\"hljs-string\">\"Hello, visitor! You've requested: %s\\n\"</span>, r.URL.Path)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    http.HandleFunc(<span class=\"hljs-string\">\"/\"</span>, greetHandler)\n    fmt.Println(<span class=\"hljs-string\">\"Starting server on :8080\"</span>)\n    <span class=\"hljs-keyword\">if</span> err := http.ListenAndServe(<span class=\"hljs-string\">\":8080\"</span>, <span class=\"hljs-literal\">nil</span>); err != <span class=\"hljs-literal\">nil</span> {\n        fmt.Printf(<span class=\"hljs-string\">\"Error starting server: %s\\n\"</span>, err)\n    }\n}\n</code></pre>\n<p>Compiled and started with:</p>\n<pre><code class=\"lang-bash\">go build -o mygoserver server.go\n./mygoserver\n</code></pre>\n<h4 id=\"heading-rust-server\">Rust Server</h4>\n<pre><code class=\"lang-rust\"><span class=\"hljs-keyword\">use</span> warp::Filter;\n\n<span class=\"hljs-meta\">#[tokio::main]</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> route = warp::path::param()\n        .map(|path: <span class=\"hljs-built_in\">String</span>| <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"Hello, visitor! You've requested: /{}\"</span>, path));\n    warp::serve(route).run(([<span class=\"hljs-number\">127</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">8081</span>)).<span class=\"hljs-keyword\">await</span>;\n}\n</code></pre>\n<p>Ran it using:</p>\n<pre><code class=\"lang-bash\">cargo run --release\n</code></pre>\n<h3 id=\"heading-load-testing-tools\">Load Testing Tools</h3>\n<p>I chose to use the <code>hey</code> tool for load testing. It's lightweight, written in Golang, and provides insightful metrics such as requests per second, latency distributions, and error rates.</p>\n<pre><code class=\"lang-bash\">go install github.com/rakyll/hey@latest\n</code></pre>\n<h3 id=\"heading-running-the-performance-tests\">Running the Performance Tests</h3>\n<p>I conducted a series of load tests on both servers. Here's the breakdown:</p>\n<ol>\n<li><p><strong>Time taken to respond to 10,000 requests with 100 concurrent requests</strong></p>\n</li>\n<li><p><strong>How many requests the servers could handle in 5 seconds with 100 concurrent requests</strong></p>\n</li>\n<li><p><strong>How many requests the servers could handle in 5 seconds with 1 concurrent request</strong></p>\n</li>\n</ol>\n<h3 id=\"heading-test-results\">Test Results</h3>\n<p>The following table summarizes the results of the performance tests.</p>\n<div class=\"hn-table\">\n<table>\n<thead>\n<tr>\n<td>Language</td><td>Requests</td><td>Concurrency</td><td>Time Taken</td><td>Errors</td><td>Requests/sec</td></tr>\n</thead>\n<tbody>\n<tr>\n<td>Golang</td><td>10,000</td><td>100</td><td>0.176 s</td><td>0</td><td>95,776.8</td></tr>\n<tr>\n<td>Rust</td><td>10,000</td><td>100</td><td>0.124 s</td><td>0</td><td>142,696.9</td></tr>\n<tr>\n<td>Golang</td><td>478,958</td><td>100</td><td>5 s</td><td>0</td><td>95,776.8</td></tr>\n<tr>\n<td>Rust</td><td>713,630</td><td>100</td><td>5 s</td><td>0</td><td>142,696.9</td></tr>\n<tr>\n<td>Golang</td><td>121,973</td><td>1</td><td>5 s</td><td>0</td><td>24,392.8</td></tr>\n<tr>\n<td>Rust</td><td>152,649</td><td>1</td><td>5 s</td><td>0</td><td>30,527.5</td></tr>\n</tbody>\n</table>\n</div><h3 id=\"heading-breakdown-of-results\">Breakdown of Results</h3>\n<h4 id=\"heading-test-1-10000-requests-100-concurrent-connections\"><strong>Test 1: 10,000 Requests, 100 Concurrent Connections</strong></h4>\n<p>In this test, Rust outperformed Golang significantly, handling 10,000 requests with 100 concurrent connections in <strong>0.124 seconds</strong>, compared to Golang's <strong>0.176 seconds</strong>. Rust also achieved a higher requests-per-second rate (142,696.9 vs. 95,776.8).</p>\n<h4 id=\"heading-test-2-5-seconds-100-concurrent-connections\"><strong>Test 2: 5 Seconds, 100 Concurrent Connections</strong></h4>\n<p>Over 5 seconds, Rust processed <strong>713,630 requests</strong>, while Golang managed <strong>478,958</strong>. Once again, Rust demonstrated superior handling of high-concurrency scenarios.</p>\n<h4 id=\"heading-test-3-5-seconds-1-concurrent-connection\"><strong>Test 3: 5 Seconds, 1 Concurrent Connection</strong></h4>\n<p>Even with only one concurrent connection, Rust managed to outperform Golang, handling <strong>30,527.5 requests per second</strong> compared to Golang's <strong>24,392.8</strong>.</p>\n<p>Hence the verdict came out to be:</p>\n<ul>\n<li><p><strong>Single concurrent request</strong>: Rust is <strong>1.25x faster than Golang</strong>.</p>\n</li>\n<li><p><strong>100 concurrent requests</strong>: Rust is <strong>1.49x faster than Golang</strong>.</p>\n</li>\n</ul>\n<h3 id=\"heading-conclusion\">Conclusion</h3>\n<p>The results speak for themselves: <strong>Rust</strong> outperforms <strong>Golang</strong> across all tests, particularly under high concurrency. While Golang is still significantly faster than Python (based on earlier tests), Rust offers even better performance with lower latency and higher throughput.</p>\n<p>In a world where efficiency matters, it's clear that Rust is an exceptional choice for performance-critical applications. However, Golang's simplicity, ease of use, and its own solid performance still make it a great choice for a wide range of projects.</p>\n<p>Friends, Romans, countrymen, I am so learning Rust AND Golang.</p>\n"},"publishedAt":"2024-10-21T08:02:12.533Z","seo":{"title":"Go vs Rust Performance Testing","description":null},"tags":[{"slug":"go"},{"slug":"rust"},{"slug":"performance"},{"slug":"performance-optimization"},{"slug":"speed"},{"slug":"blog"}]},"ogImageUrl":"https://cdn.xpri.dev/covers/67160a847278a78c9a6f488c.png"}},"staticQueryHashes":[],"slicesMap":{}}