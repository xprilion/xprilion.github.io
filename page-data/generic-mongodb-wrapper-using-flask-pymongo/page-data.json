{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/generic-mongodb-wrapper-using-flask-pymongo/","result":{"data":{"hashnode":{"publication":{"isTeam":false,"title":"Anubhav's Blog","post":{"id":"6571d85a77d326ef2b67bc50","title":"A Generic MongoDB Wrapper API with Flask and PyMongo","url":"https://xprilion.com/generic-mongodb-wrapper-using-flask-pymongo","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/cijiWIwsMB8/upload/1555ce1e680abb4a372de2e2e473f3da.jpeg"},"content":{"html":"<hr />\n<p>Hey there, hope you're well! It's been a while since I wrote something here, to my defence I wrote this tutorial about <a target=\"_blank\" href=\"https://www.digitalocean.com/community/tutorials/how-to-set-up-a-jupyterlab-environment-on-ubuntu-18-04\">How to setup a secure, remote JupyterLab workstation</a> on <a target=\"_blank\" href=\"https://digitalocean.com\">DigitalOcean</a>. Have you not read it yet? Go ahead and explore it if you're interested in the topic! Now, moving ahead.</p>\n<p>This blog is going to be about creating a generic wrapper API for your MongoDB installation using Flask and PyMongo. If you've little idea about what these terms mean, here we go -</p>\n<h2 id=\"heading-1-pymongo-and-mongodb\">1. PyMongo and MongoDB</h2>\n<p>When you're working with the cool <a target=\"_blank\" href=\"https://mongodb.com\">MongoDB</a> using Python, <a target=\"_blank\" href=\"https://pymongo.readthedocs.io/en/stable/\">PyMongo</a> is your go to tool. The distribution facilitates a full fledged support for interacting with MongoDB databases, local or remote and provides a dead simple way of working with it through your Python code.</p>\n<h2 id=\"heading-2-flask\">2. Flask</h2>\n<p>A very popular library in Python for creating web sites, often preferred for lightweight tasks and more often for creating API servers quickly, <a target=\"_blank\" href=\"https://flask.palletsprojects.com\">Flask</a> provides a way to have a no-frills web server running in minutes.</p>\n<h2 id=\"heading-3-you\">3. You</h2>\n<p><img src=\"https://media1.tenor.com/images/07feba4572471b21fd4258b6af83c9c4/tenor.gif\" alt=\"Who's awesome?\" /></p>\n<p>A super cool person reading this nice blog for whom I hope I can make the time spent here worth!</p>\n<p>Now that we're done with the introductions, let's chalk out a plan that we shall follow in this tutorial. Imagine a situation where you have a MongoDB database with yourselves, and are wondering how to use it for some basic <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Create,_read,_update_and_delete\">CRUD</a> operations from a remotely running application. Further, to make things interesting, you're unsure what collections in the database your application shall need, or it may even need to create arbitrary collections at any moment. Fortunately, you hit upon the golden idea of creating some public APIs to your database server using Flask which allow just those operations with our without some authentication, as per your need.</p>\n<p>While I'm going to leave the (tiny) headache of getting a MongoDB server to you, which you can easily get on many online providers, even for free at some places, I shall begin with the requirements of our API.</p>\n<h2 id=\"heading-the-specification\">The specification</h2>\n<p>If you went through the specification of CRUD, you know that we need 4 REST APIs to begin with -</p>\n<div class=\"hn-table\">\n<table>\n<thead>\n<tr>\n<td>Action</td><td>Method</td><td>MongoDB</td><td>Parameters</td><td>Endpoint</td></tr>\n</thead>\n<tbody>\n<tr>\n<td>Create</td><td>POST, PUT</td><td>Insert</td><td>None</td><td><a target=\"_blank\" href=\"http://example.com/table\">example.com/table</a></td></tr>\n<tr>\n<td>Read All/One</td><td>GET</td><td>Find</td><td>None/Resource ID</td><td><a target=\"_blank\" href=\"http://example.com/table/[id]\">example.com/table/[id]</a></td></tr>\n<tr>\n<td>Update</td><td>POST, PUT, PATCH</td><td>Update</td><td>Resource ID</td><td><a target=\"_blank\" href=\"http://example.com/table/id\">example.com/table/id</a></td></tr>\n<tr>\n<td>Delete</td><td>DELETE</td><td>Delete</td><td>Resource ID</td><td><a target=\"_blank\" href=\"http://example.com/table/id\">example.com/table/id</a></td></tr>\n</tbody>\n</table>\n</div><h2 id=\"heading-the-preparation\">The preparation</h2>\n<p>Now, we shall make sure we have some helper code ready for usage, usually to handle any errors on the API or simply to respond to an \"are you alive\" ping from anywhere remote.</p>\n<p>First off, you'd need the right libraries installed. We shall be using the <code>flask_pymongo</code> which is a wrapper around PyMongo with helpers for Flask provided. Besides, we will need the <code>flask_cors</code> library to <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">allow fetching of resources from a different domain</a>.</p>\n<pre><code class=\"lang-bash\">pip install flask, flask_pymongo, flask_cors\n</code></pre>\n<p>Let's import these libraries (and others which might be needed) into our script.</p>\n<h3 id=\"heading-step-1-importing-libraries\">Step 1: Importing libraries</h3>\n<p>Create a file named <a target=\"_blank\" href=\"http://app.py\"><code>app.py</code></a> in your working directory. Add the following lines to import all needed libraries -</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-keyword\">import</span> os\n<span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask, request, make_response\n<span class=\"hljs-keyword\">from</span> flask_pymongo <span class=\"hljs-keyword\">import</span> PyMongo, ObjectId\n<span class=\"hljs-keyword\">from</span> flask_cors <span class=\"hljs-keyword\">import</span> CORS\n<span class=\"hljs-keyword\">import</span> datetime\n<span class=\"hljs-keyword\">from</span> bson.json_util <span class=\"hljs-keyword\">import</span> dumps\n</code></pre>\n<h3 id=\"heading-step-2-setup-constants-mongodb-connection-and-helper-objects\">Step 2: Setup constants, MongoDB connection and helper objects</h3>\n<p>Now, let us define the stuff we shall be needing globally in the code.</p>\n<p>First, let's create an instance of our Flask app -</p>\n<pre><code class=\"lang-python\">app = Flask(__name__)\nCORS(app)\nAPP_ROOT = os.path.dirname(os.path.abspath(__file__))\n</code></pre>\n<p>The <code>CORS(app)</code> enables CORS for the API we shall run. Next, let's define some HTTP status code responses we shall be making in the API.</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-comment\"># HTTP status code constants</span>\nHTTP_SUCCESS_GET_OR_UPDATE          =   <span class=\"hljs-number\">200</span>\nHTTP_SUCCESS_CREATED                =   <span class=\"hljs-number\">201</span>\nHTTP_SUCCESS_DELETED                =   <span class=\"hljs-number\">204</span>\nHTTP_SERVER_ERROR                   =   <span class=\"hljs-number\">500</span>\nHTTP_NOT_FOUND                      =   <span class=\"hljs-number\">404</span>\nHTTP_BAD_REQUEST                    =   <span class=\"hljs-number\">400</span>\n</code></pre>\n<p>Then, create a connection object for PyMongo -</p>\n<pre><code class=\"lang-python\">app.config[<span class=\"hljs-string\">\"MONGO_URI\"</span>] = <span class=\"hljs-string\">\"mongodb://username:password@host:port/database?authSource=admin\"</span>\nmongo = PyMongo(app)\n</code></pre>\n<p>Finally, we shall be creating a helper function that prepares the responses our API makes -</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send</span>(<span class=\"hljs-params\">data, status_code</span>):</span>\n    <span class=\"hljs-keyword\">return</span> make_response(dumps(data), status_code)\n</code></pre>\n<p>This function will be responsible for preparing the data before finally giving it out through the API. Sometimes you might want global transforms on all output you're producing, this is where they go.</p>\n<h2 id=\"heading-the-real-deal\">The real deal</h2>\n<p>Now, we can setup the APIs to wrap around PyMongo. Let us start with the <code>Create</code> API.</p>\n<h3 id=\"heading-step-4-create-api\">Step 4: Create API</h3>\n<p>In this step, I shall first put out the code for you to study, and then attempt explaining it.</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-meta\">@app.route('/&lt;collection_name&gt;', methods=['POST'])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">post_item</span>(<span class=\"hljs-params\">collection_name</span>):</span>\n    <span class=\"hljs-string\">\"\"\"\n        Post one item in collection.\n    \"\"\"</span>\n    collection = getattr(mongo.db, collection_name)\n    formdata = request.json\n    <span class=\"hljs-keyword\">try</span>:\n        insert_id = str(collection.insert_one(formdata).inserted_id)\n        output = {<span class=\"hljs-string\">'message'</span>: <span class=\"hljs-string\">'new item created'</span>, <span class=\"hljs-string\">\"_id\"</span>: insert_id}\n        <span class=\"hljs-keyword\">return</span> send(output, HTTP_SUCCESS_CREATED)\n    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n        output = {<span class=\"hljs-string\">'error'</span> : str(e)}\n        <span class=\"hljs-keyword\">return</span> send(output, HTTP_BAD_REQUEST)\n</code></pre>\n<p>In the code above, you see that we created a <code>/&lt;collection_name&gt;</code> route. This means that we have kept the collection name generic, and whatever collection name is being passed to it, the API will attempt to insert data into it, or if it doesn't exist yet in the database, it will first create the collection and then insert the item.</p>\n<p>The API returns an <code>id</code> which is useful for entry level operations like reading a single entry, updating it or deleting it.</p>\n<h3 id=\"heading-step-5-read-api\">Step 5: Read API</h3>\n<p>Next, we shall create an API to read the entries in the collection. There can be two instances of read - one in which you try to read exactly 1 entry and the other where you need all entries. Let us create these.</p>\n<p>First, let's create an API that returns all items in a collection -</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-meta\">@app.route('/&lt;collection_name&gt;', methods=['GET'])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">get_all_items</span>(<span class=\"hljs-params\">collection_name</span>):</span>\n    <span class=\"hljs-string\">\"\"\"\n        Documents in a collection.\n    \"\"\"</span>\n    collection = getattr(mongo.db, collection_name)\n    output = []\n    <span class=\"hljs-keyword\">for</span> q <span class=\"hljs-keyword\">in</span> collection.find():\n        output.append(q)\n    <span class=\"hljs-keyword\">return</span> send(output, HTTP_SUCCESS_GET_OR_UPDATE)\n</code></pre>\n<p>Now, any <code>GET</code> request to any <code>collection_name</code> will attempt to display all items in that collection. If it does not exist, the API will simply return a blank list, but will not attempt to create the collection.</p>\n<p>Then, let's create the route to get information about a single entry -</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-meta\">@app.route('/&lt;collection_name&gt;/&lt;id&gt;', methods=['GET'])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">get_one_item</span>(<span class=\"hljs-params\">collection_name, id</span>):</span>\n    <span class=\"hljs-string\">\"\"\"\n        Get one item from a collection.\n    \"\"\"</span>\n    collection = getattr(mongo.db, collection_name)\n    r = collection.find_one({<span class=\"hljs-string\">'_id'</span>: ObjectId(id)})\n    <span class=\"hljs-keyword\">if</span> r:\n        <span class=\"hljs-keyword\">return</span> send(r, HTTP_SUCCESS_GET_OR_UPDATE)\n    <span class=\"hljs-keyword\">else</span>:\n        <span class=\"hljs-keyword\">return</span> send({<span class=\"hljs-string\">'error'</span> : <span class=\"hljs-string\">'item not found'</span>}, HTTP_NOT_FOUND)\n</code></pre>\n<p>Notice that the above route accepts both <code>collection_name</code> and <code>id</code>. This <code>id</code> is the one which is returned in the Create API.</p>\n<h3 id=\"heading-step-6-update-api\">Step 6: Update API</h3>\n<p>Now, let's create an API to allow updating one entry at a time. It would need to have both the <code>collection_name</code> and <code>id</code> parameters and would be accessible by a <code>PUT</code> request.</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-meta\">@app.route('/&lt;collection_name&gt;/&lt;id&gt;', methods=['PUT'])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">update_item</span>(<span class=\"hljs-params\">collection_name, id</span>):</span>\n    <span class=\"hljs-string\">\"\"\"\n        Update one item in collection.\n    \"\"\"</span>\n    collection = getattr(mongo.db, collection_name)\n    r = collection.find_one({<span class=\"hljs-string\">'_id'</span>: ObjectId(id)})\n    <span class=\"hljs-keyword\">if</span> r:\n        <span class=\"hljs-keyword\">for</span> key <span class=\"hljs-keyword\">in</span> request.json.keys():\n            r[key] = request.json[key]\n        <span class=\"hljs-keyword\">try</span>:\n            collection.replace_one({<span class=\"hljs-string\">\"_id\"</span>: ObjectId(id)}, r)\n            output = {<span class=\"hljs-string\">'message'</span> : <span class=\"hljs-string\">'item updated'</span>}\n            <span class=\"hljs-keyword\">return</span> send(output, HTTP_SUCCESS_GET_OR_UPDATE)\n        <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n            output = {<span class=\"hljs-string\">'error'</span> : str(e)}\n            <span class=\"hljs-keyword\">return</span> send(output, HTTP_BAD_REQUEST)\n    <span class=\"hljs-keyword\">else</span>:\n        output = {<span class=\"hljs-string\">'error'</span> : <span class=\"hljs-string\">'item not found'</span>}\n        <span class=\"hljs-keyword\">return</span> send(output, HTTP_NOT_FOUND)\n</code></pre>\n<p>Note that before we update the item, we check for its existence. You could skip this behaviour and could create an API which attempts to Create or Update, which is a popular requirement in many use cases.</p>\n<h3 id=\"heading-step-7-delete-api\">Step 7: Delete API</h3>\n<p>A rather simpler API, the Delete API too needs both the <code>collection_name</code> and <code>id</code> and listens to the <code>DELETE</code> request.</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-meta\">@app.route('/&lt;collection_name&gt;/&lt;id&gt;', methods=['DELETE'])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">delete_item</span>(<span class=\"hljs-params\">collection_name, id</span>):</span>\n    <span class=\"hljs-string\">\"\"\"\n        Delete one item from collection.\n    \"\"\"</span>\n    collection = getattr(mongo.db, collection_name)\n    r = collection.find_one({<span class=\"hljs-string\">'_id'</span>: ObjectId(id)})\n    <span class=\"hljs-keyword\">if</span> r:\n        <span class=\"hljs-keyword\">try</span>:\n            collection.remove(r[<span class=\"hljs-string\">\"_id\"</span>])\n            <span class=\"hljs-keyword\">return</span> send(<span class=\"hljs-string\">\"\"</span>, HTTP_SUCCESS_DELETED)\n        <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n            output = {<span class=\"hljs-string\">'error'</span> : str(e)}\n            <span class=\"hljs-keyword\">return</span> send(output, HTTP_BAD_REQUEST)\n    <span class=\"hljs-keyword\">else</span>:\n        output = {<span class=\"hljs-string\">'error'</span> : <span class=\"hljs-string\">'item not found'</span>}\n        <span class=\"hljs-keyword\">return</span> send(output, HTTP_NOT_FOUND)\n</code></pre>\n<h2 id=\"heading-conclusion\">Conclusion</h2>\n<p>With the above APIs, and any more you might wish to add to it, you can have a simple API wrapper around your MongoDB database which allows you to work with any collection at any moment. To get the full code head over to <a target=\"_blank\" href=\"https://github.com/xprilion/generic-pymongo-flask\">https://github.com/xprilion/generic-pymongo-flask</a>.</p>\n<p>If you read through the code in the <a target=\"_blank\" href=\"http://app.py\"><code>app.py</code></a> on the repository you'll find a few more functions there, which can be a useful addition to your API.</p>\n<p>Thanks for making time for going through this tutorial!</p>\n"},"publishedAt":"2020-09-14T06:30:00.000Z","seo":{"title":"100005"}}}}},"pageContext":{"slug":"generic-mongodb-wrapper-using-flask-pymongo"}},"staticQueryHashes":[],"slicesMap":{}}