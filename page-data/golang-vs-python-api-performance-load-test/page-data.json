{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/golang-vs-python-api-performance-load-test/","result":{"pageContext":{"id":"65df5be95a983bccc7dd9cbd","node":{"id":"65df5be95a983bccc7dd9cbd","slug":"golang-vs-python-api-performance-load-test","url":"https://xprilion.com/golang-vs-python-api-performance-load-test","title":"Golang vs Python: API Performance Load Test","subtitle":null,"brief":"In 2016, when I had started learning Python, I was increasingly convinced it would be the last programming language I would learn. After countless projects created with Python, a couple of technical books written, I am now learning Golang.\nWhy?\nWhile...","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1709135339797/e275e192-4549-4cbb-b364-96b04f2e911c.png"},"content":{"html":"<p>In 2016, when I had started learning Python, I was increasingly convinced it would be the last programming language I would learn. After countless projects created with Python, a couple of technical books written, I am now learning Golang.</p>\n<p>Why?</p>\n<p>While working on <a target=\"_blank\" href=\"https://callchimp.ai\">Callchimp.ai</a>, the team came across a requirement of an efficient multithreading component as part of the system infrastructure. We initially tried to pull it off using Python but the code kept getting very ugly very soon, along with being slightly beyond our understanding of how it was working.</p>\n<p>Hence, I decided to take a page from the book of world's multithreading king - Google.</p>\n<p>But before I could commit to re-writing the functionality of our component using Golang, I needed concrete numbers to support the \"uh..its faster..like zip-zap-zoom faster\" comparison of Golang with Python.</p>\n<p>Here's a short walkthrough of how I put \"zip-zap-zoom faster\" into a number.</p>\n<h2 id=\"heading-create-a-minimal-golang-server\">Create a minimal Golang server</h2>\n<p>First up, I created a barebones web server using Golang:</p>\n<pre><code class=\"lang-go\"><span class=\"hljs-comment\">// server.go</span>\n\n<span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"net/http\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">greetHandler</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request)</span></span> {\n    fmt.Fprintf(w, <span class=\"hljs-string\">\"Hello, visitor! You've requested: %s\\n\"</span>, r.URL.Path)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// Register the greetHandler with the default mux (router)</span>\n    http.HandleFunc(<span class=\"hljs-string\">\"/\"</span>, greetHandler)\n\n    <span class=\"hljs-comment\">// Start the web server on port 8080 and log any errors</span>\n    fmt.Println(<span class=\"hljs-string\">\"Starting server on :8080\"</span>)\n    <span class=\"hljs-keyword\">if</span> err := http.ListenAndServe(<span class=\"hljs-string\">\":8080\"</span>, <span class=\"hljs-literal\">nil</span>); err != <span class=\"hljs-literal\">nil</span> {\n        fmt.Printf(<span class=\"hljs-string\">\"Error starting server: %s\\n\"</span>, err)\n    }\n}\n</code></pre>\n<p>This I compiled to an executable and started its execution on port <code>8080</code> using the following commands:</p>\n<pre><code class=\"lang-bash\">go build -o mygoserver server.go\n./mygoserver\n</code></pre>\n<p>Next, I needed an equivalent Python server.</p>\n<h2 id=\"heading-create-a-minimal-python-server\">Create a minimal Python server</h2>\n<p>Since I was relying on Golang's native http library for the server, it made sense to do the same for Python. Hence, a minimal equivalent server was written:</p>\n<pre><code class=\"lang-python\"><span class=\"hljs-comment\"># server.py</span>\n\n<span class=\"hljs-keyword\">from</span> http.server <span class=\"hljs-keyword\">import</span> BaseHTTPRequestHandler, HTTPServer\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SimpleHTTPRequestHandler</span>(<span class=\"hljs-params\">BaseHTTPRequestHandler</span>):</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">do_GET</span>(<span class=\"hljs-params\">self</span>):</span>\n        self.send_response(<span class=\"hljs-number\">200</span>)\n        self.end_headers()\n        self.wfile.write(<span class=\"hljs-string\">f\"Hello, visitor! You've requested: <span class=\"hljs-subst\">{self.path}</span>\\n\"</span>.encode())\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">run</span>(<span class=\"hljs-params\">server_class=HTTPServer, handler_class=SimpleHTTPRequestHandler, port=<span class=\"hljs-number\">8081</span></span>):</span>\n    server_address = (<span class=\"hljs-string\">''</span>, port)\n    httpd = server_class(server_address, handler_class)\n    print(<span class=\"hljs-string\">f\"Starting server on :<span class=\"hljs-subst\">{port}</span>\"</span>)\n    httpd.serve_forever()\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    run()\n</code></pre>\n<p>This, I ran on port <code>8081</code> using the following command:</p>\n<pre><code class=\"lang-bash\">python server.py\n</code></pre>\n<p>With the servers up and running, I was ready to start testing them.</p>\n<h2 id=\"heading-install-a-load-test-tool\">Install a load test tool</h2>\n<p>To perform the load test, I needed an appropriate tool. I decided to use \"rakyll/hey\" for this - <a target=\"_blank\" href=\"https://github.com/rakyll/hey\">https://github.com/rakyll/hey</a>. This amazing tool is super lightweight and (interestingly?) written in Golang.</p>\n<p>Then I ran the following commands in sequence to generate outputs which I compiled in the table that comes afterwards:</p>\n<ol>\n<li><h4 id=\"heading-time-taken-to-respond-to-10000-requests-100-concurrent-requests\">Time taken to respond to 10,000 requests, 100 concurrent requests</h4>\n</li>\n</ol>\n<pre><code class=\"lang-bash\">time bash -c <span class=\"hljs-string\">'hey -n 10000 -c 100 http://localhost:8080/abc &gt;&gt; /dev/null'</span>\ntime bash -c <span class=\"hljs-string\">'hey -n 10000 -c 100 http://localhost:8081/abc &gt;&gt; /dev/null'</span>\n</code></pre>\n<ol start=\"2\">\n<li><h4 id=\"heading-how-many-requests-can-it-respond-to-in-5-seconds-100-concurrent-requests\">How many requests can it respond to in 5 seconds, 100 concurrent requests</h4>\n</li>\n</ol>\n<pre><code class=\"lang-bash\">hey -z=5s -c 100 http://localhost:8080/abc\nhey -z=5s -c 100 http://localhost:8081/abc\n</code></pre>\n<ol start=\"3\">\n<li><h4 id=\"heading-how-many-requests-can-it-respond-to-in-5-seconds-1-concurrent-request\">How many requests can it respond to in 5 seconds, 1 concurrent request</h4>\n</li>\n</ol>\n<pre><code class=\"lang-bash\">hey -z=5s -c 1 http://localhost:8080/abc\nhey -z=5s -c 1 http://localhost:8081/abc\n</code></pre>\n<p>With the tests done, it was time for the moment of truth.</p>\n<h2 id=\"heading-compiling-the-results\">Compiling the results</h2>\n<p>After running the tests, I put together my findings in this table -</p>\n<div class=\"hn-table\">\n<table>\n<thead>\n<tr>\n<td>Language</td><td>Requests</td><td>Concurrency</td><td>Time Taken</td><td>Errors</td></tr>\n</thead>\n<tbody>\n<tr>\n<td>Python</td><td>10000</td><td>100</td><td>~35s</td><td>658</td></tr>\n<tr>\n<td>Go</td><td>10000</td><td>100</td><td>~0.149s</td><td>0</td></tr>\n<tr>\n<td>Python</td><td>7948</td><td>100</td><td>5s</td><td>30</td></tr>\n<tr>\n<td>Go</td><td>473766</td><td>100</td><td>5s</td><td>0</td></tr>\n<tr>\n<td>Python</td><td>8176</td><td>1</td><td>5</td><td>0</td></tr>\n<tr>\n<td>Go</td><td>137703</td><td>1</td><td>5</td><td>0</td></tr>\n</tbody>\n</table>\n</div><p>Hence the verdict came out to be -</p>\n<ol>\n<li><p>Single concurrent request: Golang is 17x faster than Python.</p>\n</li>\n<li><p>100 concurrent requests: Golang is 60x faster than Python.</p>\n</li>\n</ol>\n<h2 id=\"heading-conclusion\">Conclusion</h2>\n<p>Friends, Romans, countrymen, I am so learning Golang.</p>\n"},"publishedAt":"2024-02-28T16:14:33.527Z","seo":{"title":null,"description":null},"tags":[{"slug":"golang"},{"slug":"python"},{"slug":"python3"},{"slug":"go"},{"slug":"performance"},{"slug":"speed"},{"slug":"web-development"},{"slug":"webdev"},{"slug":"blog"}]}}},"staticQueryHashes":[],"slicesMap":{}}